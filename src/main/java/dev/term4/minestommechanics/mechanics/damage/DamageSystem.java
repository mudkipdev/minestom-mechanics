package dev.term4.minestommechanics.mechanics.damage;import dev.term4.minestommechanics.MinestomMechanics;import dev.term4.minestommechanics.api.event.damage.DamageEvent;import dev.term4.minestommechanics.util.InvulnerabilityState;import dev.term4.minestommechanics.util.TickClock;import net.minestom.server.coordinate.Point;import net.minestom.server.entity.Entity;import net.minestom.server.entity.LivingEntity;import net.minestom.server.entity.damage.Damage;import net.minestom.server.event.Event;import net.minestom.server.event.EventNode;import net.minestom.server.tag.Tag;import static dev.term4.minestommechanics.util.InvulnerabilityState.remainingTicks;public final class DamageSystem {    // This class is the main damage system. Applies damage, fires API, determines damage type, amount, etc.    public static final float DEFAULT_AMOUNT = 1.0f;    private final EventNode<Event> apiEvents;    private static final Tag<Long> INVUL_END_TICK = Tag.Transient("mm:invul-end-tick");    private final DamageConfig config;    public DamageSystem(EventNode<Event> apiEvents, DamageConfig config) {        this.apiEvents = apiEvents;        this.config = config;    }    public void apply(DamageRequest req) {        Entity target = req.target();        if (!(target instanceof LivingEntity living)) return;        float amount = req.amount() != null ? req.amount() : DEFAULT_AMOUNT;        Entity source = req.source(); // source = projectile / explosion / etc        Entity attacker = req.attacker(); // attacker = entity responsible (mob, player)        Point sourcePos = req.sourcePosition();        boolean invulnerable = InvulnerabilityState.isInvulnerable(living);        int remaining = invulnerable ? remainingTicks(living) : 0;        // API        DamageEvent event = new DamageEvent(target, req.type(), req.source(), amount, invulnerable, remaining, config);        apiEvents.call(event);        if (event.cancelled() || (event.invulnerable() && !event.bypassInvul())) return;        amount = event.amount();        if (amount <= 0) return;        // Build damage        Damage damage = new Damage(                req.type(),                source,                attacker,                sourcePos,                amount        );        living.damage(damage);        InvulnerabilityState.setInvulnerable(living, event.config().invulTicks);    }    public static DamageSystem install(MinestomMechanics mm, DamageConfig cfg) {        var system = new DamageSystem(mm.events(), cfg);        mm.registerDamage(system);        return system;    }}